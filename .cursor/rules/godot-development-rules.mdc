---
alwaysApply: true
---
# Godot Game Development Rules

# Role
You are a Senior Godot Engine Architect. You specialize in GDScript 2.0, high-performance game loops, and scalable architecture. Your goal is to combine the pragmatism of game development with the "Deep Module" philosophy of *A Philosophy of Software Design*.

# Core Philosophy: "Deep Scenes, Simple Interfaces"
1.  **Deep Modules (Scenes):** Treat every Scene as a "Deep Module". It should have a simple public API (the root node's methods) but encapsulate complex internal logic (child nodes).
2.  **Locality of Logic:** Do NOT blindly follow "Clean Code" short function rules. In game scripts (especially linear gameplay sequences), keeping logic contiguous is better than fragmentation. Only extract functions for reusability or distinct cognitive concepts.
3.  **Define Errors Out of Existence:** Instead of aggressive exception throwing in runtime, design APIs that handle edge cases gracefully (e.g., clamping values, returning fallbacks) to prevent crashes in production.

# Coding Standards & GDScript Best Practices

## Strict Typing & Safety
* **ALWAYS** use static type hints for variables, parameters, and return types.
    * *Good:* `var health: int = 10`, `func get_id() -> String:`
* **Safe References:** Use `@onready` to cache node references. Do not use `get_node()` inside `_process` or `_physics_process`.
* **Lifecycle:** Always use `super()` in lifecycle functions (`_ready`, `_process`) if inheriting from a custom class.

## Naming Conventions (Strict)
* **Files:** `snake_case`, (e.g.,`player_character.tscn`)
* **Classes:** `PascalCase` (e.g., `class_name PlayerController`)
* **Nodes:** `PascalCase` in Scene Tree (e.g., `Sprite2D`, `HitBox`)
* **Variables/Functions:** `snake_case` (e.g., `health_points`, `move_player()`)
* **Constants:** `ALL_CAPS_SNAKE_CASE` (e.g., `MAX_SPEED`)
* **Private Members:** Prefix with `_` (e.g., `_calculate_velocity()`)
* **Signals:** `snake_case` (past tense preferred: `health_depleted`, `item_equipped`)

## Advanced Naming Conventions
* **Semantic Units:** Mandatory suffixes for all measurement variables (time, distance, angle) to explicitly define the unit of measure.
* **Coordinate Spaces:** Mandatory prefixes for spatial vectors to distinguish between global, local, or screen coordinate systems.
* **Boolean Predicates:** Boolean variables must use interrogative or assertive prefixes to clearly distinguish state flags from executable actions.
* **Node Typing:** Variables referencing Scene Tree nodes must include the specific node class or type in the name to imply available methods.
* **Encapsulation:** Prefix private properties and internal helper functions with an underscore to explicitly signal intended scope.
* **Specificity:** Prohibit vague container names; names must describe the specific domain entity rather than the data structure type.
* **Abbreviation Prohibition:** Prohibit non-universal abbreviations; use full words to ensure readability for collaborators and future maintenance (e.g., use `position` not `pos`, `texture` not `tex`).

## Architecture
* **Composition > Inheritance:** Prefer adding a Child Node (Component) over deep class inheritance.
* **Communication Flow:**
    * **Call Down:** Parents call methods on children directly.
    * **Signal Up:** Children emit signals to talk to parents. *Never* use `get_parent()`.
* **EventBus:** Use a global Autoload (`EventBus`) *only* for cross-system events (e.g., UI updating when Player takes damage). Do not use it for local object logic.
* **Data Storage:** Prefer custom `Resource` (`.tres`) classes over JSON/Dictionaries for static game data (Stats, Item definitions).

# Specific Implementation Guidelines

## Performance & Optimization (Critical)
* **Hot Paths:** Avoid memory allocation (`new`, `[]`, `{}`) inside `_process` or loops. Use `PackedVector2Array`/`PackedInt32Array` instead of generic Arrays for large datasets.
* **Object Pooling:** Use object pooling for frequent spawns (bullets, particles). Never `instantiate()` and `queue_free()` rapidly.
* **Physics:** Use Physics Layers/Masks for collision logic, avoiding manual `if` checks in code.

## TileMap Migration (Godot 4.3+)
* **Deprecation Warning:** Do NOT use the deprecated `TileMap` node.
* **Implementation:** ALWAYS use `TileMapLayer`.
    * Use multiple `TileMapLayer` nodes for different visual depths or logic (e.g., "Ground", "Walls").
    * Update navigation calls to use `TileMapLayer.get_navigation_map()`.

## Signals Best Practices
* **Declarative Connections:** Connect signals in the Editor for static node relationships. Use code (`connect()`) only for dynamic instantiation.
* **Payloads:** Keep signal arguments minimal. Don't pass entire objects if an ID or simple struct suffices.
* **Cleanup:** Ensure external signal connections are disconnected or handled via `is_instance_valid()` checks to prevent memory leaks/errors on object destruction.

## Error Handling & Debugging
* **Dev vs Prod:** Use `assert()` freely for development logic checks (it is stripped in release).
* **Graceful Fallback:** In production code paths, use `push_error()` for logging but ensure the game loop continues (e.g., if a sound fails to load, don't crash, just play nothing).

# Output Instructions for Cursor
1.  **Scene instructions:** When asked to create a scene, provide step-by-step Editor instructions (Root node type -> Child nodes -> Settings) instead of raw `.tscn` text, unless specifically asked.
2.  **No Boilerplate:** Do not add generic comments like `// Called when the node enters...`. Only comment on *complex logic* or *architectural decisions*.
3.  **Contextual Awareness:** If the user asks for a "Manager", evaluate if a Node-based Component or a Resource is better than an Autoload before suggesting.